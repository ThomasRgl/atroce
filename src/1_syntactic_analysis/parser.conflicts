
** Conflict (reduce/reduce) in state 65.
** Tokens involved: Lsub Lsc Lneq Lmul Llt Lle Lgt Lge Leq Ldiv Lcomma Lassign Ladd
** The following explanations concentrate on token Lsub.
** This state is reached from prog after reading:

Lvar Lvar Lopar loption(separated_nonempty_list(Lcomma,param)) Lcpar Lobrace Lvar Lmul Lvar

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

prog 
def prog 
funcDef 
Lvar Lvar Lopar loption(separated_nonempty_list(Lcomma,param)) Lcpar Lobrace block Lcbrace 
                                                                             list(instr) 
                                                                             instr list(instr) 
                                                                             declInstr Lsc 
                                                                             (?)

** In state 65, looking ahead at Lsub, reducing production
** valueAdrrExpr -> Lmul Lvar
** is permitted because of the following sub-derivation:

Lvar separated_nonempty_list(Lcomma,expr) 
     expr 
     opExpr 
     expr Lsub expr // lookahead token appears
     valueAdrrExpr // lookahead token is inherited
     Lmul Lvar . 

** In state 65, looking ahead at Lsub, reducing production
** varExpr -> Lvar
** is permitted because of the following sub-derivation:

Lvar Lmul separated_nonempty_list(Lcomma,expr) 
          expr 
          opExpr 
          expr Lsub expr // lookahead token appears
          varExpr // lookahead token is inherited
          Lvar . 

** Conflict (shift/reduce) in state 63.
** Token involved: Lmul
** This state is reached from prog after reading:

Lvar Lvar Lopar loption(separated_nonempty_list(Lcomma,param)) Lcpar Lobrace Lvar

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

prog 
def prog 
funcDef 
Lvar Lvar Lopar loption(separated_nonempty_list(Lcomma,param)) Lcpar Lobrace block Lcbrace 
                                                                             list(instr) 
                                                                             instr list(instr) 
                                                                             (?)

** In state 63, looking ahead at Lmul, shifting is permitted
** because of the following sub-derivation:

declInstr Lsc 
Lvar . Lmul separated_nonempty_list(Lcomma,expr) 

** In state 63, looking ahead at Lmul, reducing production
** varExpr -> Lvar
** is permitted because of the following sub-derivation:

exprInstr Lsc 
expr 
opExpr 
expr Lmul expr // lookahead token appears
varExpr // lookahead token is inherited
Lvar . 
